<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>基本型（スコア編集版）</title>
    <style>
      body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 0;
        padding: 20px;
        width: 100%;
        min-height: 100vh;
        background-image: url("./img/back.png");
        background-size: cover;
        background-position: center;
      }

      #title-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
        z-index: 100;
      }

      #title-screen button {
        padding: 12px 24px;
        font-size: 1.2em;
        cursor: pointer;
      }

      .grid-area {
        flex-shrink: 0;
        width: fit-content;
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(8, 110px);
        grid-template-rows: repeat(8, 110px);
        gap: 4px;
        padding: 8px;
        border: 6px solid #1a2c3d;
        border-radius: 16px;
        background-color: #243b55;
      }

      .cell {
        width: 110px;
        height: 110px;
        background-color: transparent;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .block-selection {
        display: flex;
        flex-direction: row;
        gap: 30px;
        justify-content: center;
      }

      .block {
        display: grid;
        gap: 4px;
        cursor: grab;
      }

      .block-cell {
        width: 110px;
        height: 110px;
        background-image: url("./img/mokume.jpg");
        background-size: cover;
        background-position: center;
        border-radius: 8px;
        box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.3);
      }

      .transparent-cell {
        width: 110px;
        height: 110px;
        background-color: transparent;
      }

      .score-display {
        font-family: "Arial Rounded MT Bold", sans-serif;
        font-size: 32px;
        color: #ffecd1;
        background-color: rgba(0, 0, 0, 0.4);
        padding: 10px 20px;
        border-radius: 12px;
      }

      .game-over-container {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 40px;
        border-radius: 16px;
        z-index: 10;
        display: none;
      }

      .game-over {
        font-size: 3em;
        color: red;
        font-weight: bold;
        text-shadow: 2px 2px 4px black;
      }

      #continue-btn {
        align-items: center;
        background-image: linear-gradient(
          144deg,
          #af40ff,
          #5b42f3 50%,
          #00ddeb
        );
        border: 0;
        border-radius: 8px;
        box-shadow: rgba(151, 65, 252, 0.2) 0 15px 30px -5px;
        box-sizing: border-box;
        color: #ffffff;
        display: flex;
        font-size: 18px;
        justify-content: center;
        line-height: 1em;
        min-width: 140px;
        padding: 3px;
        text-decoration: none;
        user-select: none;
        white-space: nowrap;
        cursor: pointer;
        transition: all 0.3s ease;
        transform: scale(0.95);
      }

      #continue-btn span {
        background-color: rgb(5, 6, 45);
        padding: 16px 24px;
        border-radius: 6px;
        display: inline-block;
        text-align: center;
        transition: 300ms;
      }

      #continue-btn:hover {
        transform: scale(1);
      }

      #continue-btn:hover span {
        background: none;
      }

      #continue-btn:active {
        transform: scale(0.9);
      }
    </style>
  </head>

  <body>
    <div id="title-screen">
      <h1>ブロックパズルゲーム</h1>
      <button id="start-btn">ゲームスタート</button>
      <button id="rules-btn">ルール説明</button>
    </div>

    <div class="score-display" id="score-display">スコア: 0</div>
    <div class="grid-area">
      <div class="grid" id="grid"></div>
    </div>
    <div class="block-selection" id="block-selection"></div>

    <div class="game-over-container" id="game-over-container">
      <div id="game-over" class="game-over">Game Over !</div>
      <button id="continue-btn"><span>コンティニュー</span></button>
    </div>

    <script>
      const titleScreen = document.getElementById("title-screen");
      const startBtn = document.getElementById("start-btn");
      const rulesBtn = document.getElementById("rules-btn");
      const gameOverContainer = document.getElementById("game-over-container");
      const continueBtn = document.getElementById("continue-btn");
      const scoreDisplay = document.getElementById("score-display");
      const grid = document.getElementById("grid");
      const blockSelection = document.getElementById("block-selection");

      const GRID_SIZE = 8;
      const CELL_SIZE = 114;
      let cells = [];
      let score = 0;
      const blockShapes = [
        [
          [1, 1, 1],
          [0, 1, 0],
        ],
        [[1, 1, 1, 1, 1]],
        [
          [1, 1],
          [1, 1],
        ],
        [
          [1, 1, 0],
          [0, 1, 1],
        ],
        [
          [0, 1, 1],
          [1, 1, 0],
        ],
        [
          [1, 0],
          [1, 0],
          [1, 1],
        ],
        [
          [0, 1],
          [0, 1],
          [1, 1],
        ],
      ];

      startBtn.addEventListener("click", () => {
        titleScreen.style.display = "none";
        initGrid();
        fillBlockSelection();
      });

      rulesBtn.addEventListener("click", () => {
        alert("ルール：ブロックを配置して行または列1本をそろえると1点！");
      });

      function updateScore(points) {
        score += points;

        // localStorageに保存されているこれまでの合計スコアを取得し、数値に変換
        const currentTotalScore =
          parseInt(localStorage.getItem("game2"), 10) || 0;

        // 今回獲得したポイントをこれまでの合計スコアに加算
        const newTotalScore = currentTotalScore + score;

        // 新しい合計スコアをlocalStorageに保存（
        localStorage.setItem("game2", newTotalScore.toString());

        scoreDisplay.textContent = `スコア: ${score}`; // 画面表示のスコアを更新
      }

      function initGrid() {
        grid.innerHTML = "";
        cells = [];
        for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.dataset.index = i;
          grid.appendChild(cell);
          cells.push(cell);
        }
        score = 0;
        updateScore(0);
      }

      function createBlock(shape) {
        const block = document.createElement("div");
        block.className = "block";
        block.draggable = true;
        block.dataset.shape = JSON.stringify(shape);
        block.dataset.id = Math.random().toString(36).substr(2, 9);
        block.style.gridTemplateColumns = `repeat(${shape[0].length}, 110px)`;
        block.style.gridTemplateRows = `repeat(${shape.length}, 110px)`;
        for (let y = 0; y < shape.length; y++) {
          for (let x = 0; x < shape[y].length; x++) {
            const cell = document.createElement("div");
            cell.className = shape[y][x] ? "block-cell" : "transparent-cell";
            block.appendChild(cell);
          }
        }
        block.addEventListener("dragstart", (e) => {
          const rect = block.getBoundingClientRect();
          const offsetX = e.clientX - rect.left;
          const offsetY = e.clientY - rect.top;
          e.dataTransfer.setData(
            "text/plain",
            JSON.stringify({ shape, offsetX, offsetY, id: block.dataset.id })
          );
        });
        return block;
      }

      function fillBlockSelection() {
        blockSelection.innerHTML = "";
        for (let i = 0; i < 3; i++) {
          const shape =
            blockShapes[Math.floor(Math.random() * blockShapes.length)];
          blockSelection.appendChild(createBlock(shape));
        }
      }

      grid.addEventListener("dragover", (e) => e.preventDefault());

      grid.addEventListener("drop", (e) => {
        e.preventDefault();
        const data = JSON.parse(e.dataTransfer.getData("text/plain"));
        const { shape, offsetX, offsetY, id } = data;
        const rect = grid.getBoundingClientRect();
        const x = Math.round((e.clientX - rect.left - offsetX) / CELL_SIZE);
        const y = Math.round((e.clientY - rect.top - offsetY) / CELL_SIZE);
        if (canPlace(x, y, shape)) {
          place(x, y, shape);
          const lines = clearLines();
          updateScore(lines);
          const block = [...blockSelection.children].find(
            (b) => b.dataset.id === id
          );
          if (block) {
            const idx = [...blockSelection.children].indexOf(block);
            block.remove();
            const newShape =
              blockShapes[Math.floor(Math.random() * blockShapes.length)];
            blockSelection.insertBefore(
              createBlock(newShape),
              blockSelection.children[idx] || null
            );
          }
          checkGameOver();
        }
      });

      function canPlace(sx, sy, shape) {
        return shape.every((row, dy) =>
          row.every((cell, dx) => {
            if (!cell) return true;
            const x = sx + dx;
            const y = sy + dy;
            if (x < 0 || y < 0 || x >= GRID_SIZE || y >= GRID_SIZE)
              return false;
            return !cells[y * GRID_SIZE + x].classList.contains("block-cell");
          })
        );
      }

      function place(sx, sy, shape) {
        shape.forEach((row, dy) =>
          row.forEach((cell, dx) => {
            if (cell) {
              cells[(sy + dy) * GRID_SIZE + (sx + dx)].classList.add(
                "block-cell"
              );
            }
          })
        );
      }

      function clearLines() {
        let cleared = 0;
        for (let y = 0; y < GRID_SIZE; y++) {
          const rowCells = cells.slice(y * GRID_SIZE, (y + 1) * GRID_SIZE);
          if (rowCells.every((c) => c.classList.contains("block-cell"))) {
            rowCells.forEach((c) => c.classList.remove("block-cell"));
            cleared++;
          }
        }
        for (let x = 0; x < GRID_SIZE; x++) {
          const colCells = Array.from(
            { length: GRID_SIZE },
            (_, i) => cells[i * GRID_SIZE + x]
          );
          if (colCells.every((c) => c.classList.contains("block-cell"))) {
            colCells.forEach((c) => c.classList.remove("block-cell"));
            cleared++;
          }
        }
        return cleared;
      }

      function checkGameOver() {
        const blocks = Array.from(blockSelection.children);
        const canPlaceAny = blocks.some((b) => {
          const shape = JSON.parse(b.dataset.shape);
          for (let y = 0; y <= GRID_SIZE - shape.length; y++) {
            for (let x = 0; x <= GRID_SIZE - shape[0].length; x++) {
              if (canPlace(x, y, shape)) return true;
            }
          }
          return false;
        });
        if (!canPlaceAny) {
          gameOverContainer.style.display = "flex";
        }
      }

      continueBtn.addEventListener("click", () => {
        gameOverContainer.style.display = "none";
        initGrid();
        fillBlockSelection();
      });

      initGrid();
      fillBlockSelection();
    </script>
  </body>
</html>
